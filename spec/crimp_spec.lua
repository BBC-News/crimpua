require 'busted.runner'()
Crimpua = require("crimp")

describe("The notation strings", function()
    describe("Given a nil value", function()
        it("returns an underscore", function()
            assert.is_equal("_", Crimpua.notation(nil))
        end)
    end)
    describe("Given a single string", function()
        it("returns the string with an S suffix", function()
            assert.is_equal("abcS", Crimpua.notation("abc"))
        end)
    end)
    describe("Given a single integer", function()
        it("returns the integer with an N siffix", function()
            assert.is_equal("1N", Crimpua.notation(1))
        end)
    end)
    describe("Given a single float", function()
        it("returns the integer with an N siffix", function()
            assert.is_equal("1.2N", Crimpua.notation(1.2))
        end)
    end)
    describe("Given a single true value", function()
        it("returns the string true with a B suffix", function()
            assert.is_equal("trueB", Crimpua.notation(true))
        end)
    end)
    describe("Given a single false value", function()
        it("returns the string true with a B suffix", function()
            assert.is_equal("falseB", Crimpua.notation(false))
        end)
    end)
    describe("Given an array", function()
        it("returns all the notated values with an A suffix", function()
            assert.is_equal("1N3NaSA", Crimpua.notation({1, "a", 3}))
        end)
    end)
--    # Lua tables make no distinction between a table value being nil and the corresponding key not existing in the table
--    # this makes this case unecessary, and not easily matchable in lua
--    # although some users use null = {} and check for null rather than nil to handle this
--    describe("Given an array containing nil", function()
--        it("returns all the notated values with an A suffix", function()
--            assert.is_equal("_1N3NaSA", Crimpua.notation({3, nil, 1, "1"}))
--        end)
--    end)
    describe("Given an array containing capital letters", function()
        it("returns all the notated values with an A suffix", function()
            assert.is_equal("ASBSaSbSA", Crimpua.notation({"a", "A", "b", "B"}))
        end)
    end)
    describe("Given an array containing a nested array", function()
        it("returns all the notated values with an A suffix", function()
            assert.is_equal("1N2SbSAaSA", Crimpua.notation({"a", 1, {"b", "2"}}))
        end)
    end)
    describe("Given an array containing a nested array in a different order", function()
        it("returns all the notated values in the right order with an A suffix", function()
            assert.is_equal("1N2SbSAaSA", Crimpua.notation({{"b", "2"}, "a", 1}))
        end)
    end)
    describe("Given a table with named keys", function()
        it("returns the key value pair as an array with an H suffix", function()
            assert.is_equal("1NaSAH", Crimpua.notation({a=1}))
        end)
    end)
--    # Lua tables make no distinction between a table value being nil and the corresponding key not existing in the table
--    # this makes this case unecessary, and not easily matchable in lua
--    # although some users use null = {} and check for null rather than nil to handle this
--    describe("Given a nested table with named keys", function()
--        it("returns the key value pairs as an array within an array with the H suffixes", function()
--            assert.is_equal("1NaSAH", Crimpua.notation({a = {c = nil, [2] = 2}}))
--        end)
--    end)
    describe("Given a nested table with named keys", function()
        it("returns the key value pairs as an array within an array with the H suffixes", function()
            assert.is_equal("aS2S2NAcSfooSAHAH", Crimpua.notation({a = {c = "foo", [2] = 2}}))
        end)
    end)
    describe("Given an array of tables with named keys", function()
        it("returns the key value pairs as an array within an array with the H suffixes", function()
            assert.is_equal("aSaooSAbSbooSAHcScooSAeSeooSAHA", Crimpua.notation({{c = "coo", e = "eoo"}, {a = "aoo", b = "boo"}}))
        end)
    end)
end)

describe("The MD5 signature output", function()
    describe("Given a nil value", function()
        it("returns the correct signature", function()
            assert.is_equal("b14a7b8059d9c055954c92674ce60032", Crimpua.signature(nil))
        end)
    end)
    describe("Given a single string", function()
        it("returns the correct signature", function()
            assert.is_equal("c4449120506d97975c67be69719a78e2", Crimpua.signature("abc"))
        end)
    end)
    describe("Given a single integer", function()
        it("returns the correct signature", function()
            assert.is_equal("594170053719896a11eb08ee513813d5", Crimpua.signature(1))
        end)
    end)
    describe("Given a single float", function()
        it("returns the correct signature", function()
            assert.is_equal("f1ab6592886cd4b1b66ed55e73d9ab81", Crimpua.signature(1.2))
        end)
    end)
    describe("Given a single true value", function()
        it("returns the correct signature", function()
            assert.is_equal("6413cfeb7a89f7e0a8872f82b919c0d9", Crimpua.signature(true))
        end)
    end)
    describe("Given a single false value", function()
        it("returns the correct signature", function()
            assert.is_equal("fa39253035cfe44c8638b8f5d7a3402e", Crimpua.signature(false))
        end)
    end)
    describe("Given an array", function()
        it("returns the correct signature", function()
            assert.is_equal("cd1c43797d488d0f6c0d71537c64d30b", Crimpua.signature({1, "a", 3}))
        end)
    end)
    --    # Lua tables make no distinction between a table value being nil and the corresponding key not existing in the table
    --    # this makes this case unecessary, and not easily matchable in lua
    --    # although some users use null = {} and check for null rather than nil to handle this
    --    describe("Given an array containing nil", function()
    --        it("returns the correct signature", function()
    --            assert.is_equal("518e7bb17674f6acbb296845862a152d", Crimpua.signature({3, nil, 1, "1"}))
    --        end)
    --    end)
    describe("Given an array containing capital letters", function()
        it("returns the correct signature", function()
            assert.is_equal("f6692ab4bc94b35e61ec15c2d1891734", Crimpua.signature({"a", "A", "b", "B"}))
        end)
    end)
    describe("Given an array containing a nested array", function()
        it("returns the correct signature", function()
            assert.is_equal("3aaa58da4841eaeb41d3726d2c6fd875", Crimpua.signature({"a", 1, {"b", "2"}}))
        end)
    end)
    describe("Given an array containing a nested array in a different order", function()
        it("returns the correct signature", function()
            assert.is_equal("3aaa58da4841eaeb41d3726d2c6fd875", Crimpua.signature({{"b", "2"}, "a", 1}))
        end)
    end)
    describe("Given a table with named keys", function()
        it("returns the correct signature", function()
            assert.is_equal("8cb44d69badda0f34b0bab6bb3e7fdbf", Crimpua.signature({a=1}))
        end)
    end)
    --    # Lua tables make no distinction between a table value being nil and the corresponding key not existing in the table
    --    # this makes this case unecessary, and not easily matchable in lua
    --    # although some users use null = {} and check for null rather than nil to handle this
    --    describe("Given a nested table with named keys", function()
    --        it("returns the correct signature", function()
    --            assert.is_equal("518e7bb17674f6acbb296845862a152d", Crimpua.notation({a = {c = nil, [2] = 2}}))
    --        end)
    --    end)
    describe("Given a nested table with named keys", function()
        it("returns the correct signature", function()
            assert.is_equal("0347653529767f93c14738a38c11e571", Crimpua.signature({a = {c = "foo", [2] = 2}}))
        end)
    end)
    describe("Given an array of tables with named keys", function()
        it("returns the correct signature", function()
            assert.is_equal("18df21bc35321f8451607205a1ad9e95", Crimpua.signature({{c = "coo", e = "eoo"}, {a = "aoo", b = "boo"}}))
        end)
    end)
end)